// Each of these rules have a corresponding method in the Parser class.

-> program: (statement_list)* // A program is any single file
-> statement_list: statement | compound_statement | statement SEMI statement_list
-> statement: declarations | reDeclaration
-> compound_statement: LCURLY statement_list RCURLY

// Declarations can be: variable, constant, function, enum, struct, or class declarations
-> declarations: (var_declarations SEMI)+ | (const_declarations SEMI)+ | (func_declaration)+

-> var_declarations: LET identifier (COMMA identifier)* type_spec (ASSIGN expr)
-> const_declarations: CONST identifier (COMMA identifier)* type_spec ASSIGN expr
-> func_declaration: FUNC identifier LPAREN RPAREN type_spec compound_statement
-> reDeclaration: identifier (COMMA identifier)* ASSIGN expr

-> type_spec: COLON Builtin_Type

-> expr: term ((PLUS | MINUS) term)*
        | LBRAKET (expr | (expr COMMA)*) RBRAKET
        | INTEGER_LITERAL RANGE_OPERATOR INTEGER_LITERAL
-> term: factor ((MUL | DIV | MOD) factor)*
-> factor: atom (POW factor)*
-> atom: PLUS factor
        | MINUS factor
        | INTEGER_LITERAL
        | REAL_LITERAL
        | NONE_LITERAL
        | TRUE_LITERAL
        | FALSE_LITERAL
        | STRING_LITERAL
        | LPAREN expr RPAREN
        | identifier


-> identifier: ID

-> Builtin_Type: INTEGER | REAL

-> empty:
